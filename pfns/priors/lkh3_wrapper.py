import os
import subprocess
import tempfile
import numpy as np
from typing import List, Tuple, Dict, Optional
import time
import shutil


class LKH3Wrapper:
    """
    Python wrapper for LKH3 TSP solver.
    Provides functionality to solve TSP instances and generate candidate sets.
    """
    
    def __init__(self, lkh_executable_path: str = None):
        """
        Initialize the LKH3 wrapper.
        
        Args:
            lkh_executable_path: Path to the LKH executable. If None, uses LKH in the same directory.
        """
        if lkh_executable_path is None:
            # Use LKH executable in the same directory as this script
            current_dir = os.path.dirname(os.path.abspath(__file__))
            lkh_executable_path = os.path.join(current_dir, "LKH")
        
        self.lkh_executable_path = lkh_executable_path
        if not os.path.exists(lkh_executable_path):
            raise FileNotFoundError(f"LKH executable not found at {lkh_executable_path}")
        
        # Create temp directory for LKH3 files
        self.temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "lkh3_temp")
        os.makedirs(self.temp_dir, exist_ok=True)
    
    def create_tsp_file(self, coords: np.ndarray, filename: str, scale: int = 1000) -> str:
        """
        Create a TSP file from coordinates with proper SCALE parameter.
        
        Args:
            coords: Array of shape (n, 2) containing x, y coordinates
            filename: Name for the TSP file
            scale: Scale factor for distance calculation (default: 1000)
            
        Returns:
            Path to the created TSP file
        """
        n_nodes = len(coords)
        
        tsp_content = f"""NAME: {filename}
TYPE: TSP
DIMENSION: {n_nodes}
EDGE_WEIGHT_TYPE: EUC_2D
SCALE: {scale}
NODE_COORD_SECTION
"""
        
        for i, (x, y) in enumerate(coords):
            tsp_content += f"{i+1} {x:.6f} {y:.6f}\n"
        
        tsp_content += "EOF\n"
        
        tsp_file_path = os.path.join(self.temp_dir, f"{filename}.tsp")
        with open(tsp_file_path, 'w') as f:
            f.write(tsp_content)
        
        return tsp_file_path
    
    def create_parameter_file(self, tsp_file: str, candidate_file: str, 
                            max_candidates: int = 5, runs: int = 1, 
                            time_limit: Optional[int] = None, tour_file: str = None,
                            alpha: float = None) -> str:
        """
        Create a parameter file for LKH3 using SPECIAL mode with MAX_TRIALS=10000.
        
        Args:
            tsp_file: Path to the TSP file
            candidate_file: Path where candidate file should be written
            max_candidates: Maximum number of candidates per node
            runs: Number of runs
            time_limit: Time limit in seconds (optional)
            tour_file: Path where tour should be written (optional)
            alpha: Alpha value for candidate generation (controls EXCESS parameter)
            
        Returns:
            Path to the created parameter file
        """
        param_content = f"""PROBLEM_FILE = {tsp_file}
CANDIDATE_FILE = {candidate_file}
MAX_CANDIDATES = {max_candidates}
RUNS = {runs}
SPECIAL
MAX_TRIALS = 10000
"""
        
        if time_limit is not None:
            param_content += f"TIME_LIMIT = {time_limit}\n"
        else:
            # Set reasonable time limit
            param_content += "TIME_LIMIT = 60\n"  # Default 60 seconds
        
        if tour_file is not None:
            param_content += f"TOUR_FILE = {tour_file}\n"
        
        if alpha is not None:
            param_content += f"EXCESS = {alpha}\n"
        
        param_file = os.path.join(self.temp_dir, f"{os.path.basename(os.path.splitext(tsp_file)[0])}.par")
        with open(param_file, 'w') as f:
            f.write(param_content)
        
        return param_file
    
    def parse_candidate_file(self, candidate_file: str) -> Dict:
        """
        Parse the candidate file generated by LKH3.
        
        Args:
            candidate_file: Path to the candidate file
            
        Returns:
            Dictionary containing candidate information:
            - dimension: Number of nodes
            - candidates: Dict mapping node_id to list of (neighbor_id, alpha_value) tuples
            - mst_parents: Dict mapping node_id to parent in MST (0 if root)
        """
        if not os.path.exists(candidate_file):
            raise FileNotFoundError(f"Candidate file not found: {candidate_file}")
        
        candidates = {}
        mst_parents = {}
        dimension = 0
        
        with open(candidate_file, 'r') as f:
            lines = f.readlines()
        
        if not lines:
            raise ValueError("Empty candidate file")
        
        # First line contains dimension
        dimension = int(lines[0].strip())
        
        # Parse each node's information
        for line in lines[1:]:
            line = line.strip()
            if not line or line == "-1" or line == "EOF":
                continue
                
            parts = line.strip().split()
            if len(parts) < 3:
                continue
            
            node_id = int(parts[0])
            mst_parent = int(parts[1])
            num_candidates = int(parts[2])
            
            mst_parents[node_id] = mst_parent
            
            # Parse candidate edges
            node_candidates = []
            for i in range(num_candidates):
                if 3 + 2*i + 1 < len(parts):
                    neighbor_id = int(parts[3 + 2*i])
                    alpha_value = float(parts[3 + 2*i + 1])
                    node_candidates.append((neighbor_id, alpha_value))
            
            candidates[node_id] = node_candidates
        
        return {
            'dimension': dimension,
            'candidates': candidates,
            'mst_parents': mst_parents
        }
    
    def solve_tsp_with_candidates(self, coords: np.ndarray, max_candidates: int = 5, 
                                runs: int = 1, cleanup: bool = True, 
                                instance_name: str = None, alpha: float = None,
                                scale: int = 1000) -> Tuple[List[int], Dict]:
        """
        Solve TSP and generate candidate sets using LKH3 with proper scaling.
        
        Args:
            coords: Array of shape (n, 2) containing x, y coordinates
            max_candidates: Maximum number of candidates per node
            runs: Number of runs
            cleanup: Whether to clean up temporary files
            instance_name: Name for the instance (auto-generated if None)
            alpha: Alpha value for candidate generation (controls EXCESS parameter)
            scale: Scale factor for distance calculation (default: 1000)
            
        Returns:
            Tuple of (tour, candidate_info):
            - tour: List of node indices representing the optimal tour
            - candidate_info: Dictionary containing candidate set information
        """
        import threading
        import random
        
        if instance_name is None:
            # Use thread ID and random number to ensure multi-thread safety
            thread_id = threading.get_ident()
            random_id = random.randint(10000, 99999)
            timestamp = int(time.time() * 1000000)  # Microsecond timestamp
            instance_name = f"temp_lkh_{thread_id}_{timestamp}_{random_id}"
        
        # Create TSP file with proper scale
        tsp_file = self.create_tsp_file(coords, instance_name, scale)
        
        # Create candidate file path (in temp directory)
        candidate_file = os.path.join(self.temp_dir, f"{instance_name}.cand")
        
        # Create tour file path (in temp directory)
        tour_file = os.path.join(self.temp_dir, f"{instance_name}.tour")
        
        # Improved parameter settings
        improved_max_candidates = max(max_candidates, len(coords) // 2)  # At least half the number of nodes
        improved_runs = max(runs, 3)  # At least 3 runs
        
        # Create parameter file
        param_file = self.create_parameter_file(
            tsp_file, candidate_file, improved_max_candidates, improved_runs, 
            tour_file=tour_file, alpha=alpha
        )
        
        try:
            # Set timeout based on problem size
            timeout_seconds = max(60, len(coords) * 3)  # At least 60 seconds, longer for larger problems
            
            # Run LKH3
            result = subprocess.run(
                [self.lkh_executable_path, param_file],
                capture_output=True,
                text=True,
                timeout=timeout_seconds
            )
            
            if result.returncode != 0:
                raise RuntimeError(f"LKH3 failed with return code {result.returncode}\n"
                                 f"stdout: {result.stdout}\n"
                                 f"stderr: {result.stderr}")
            
            # Parse candidate file
            candidate_info = self.parse_candidate_file(candidate_file)
            
            # Extract tour from tour file if it exists, otherwise from output
            tour = []
            if os.path.exists(tour_file):
                tour = self._extract_tour_from_file(tour_file)
            else:
                tour = self._extract_tour_from_output(result.stdout)
            
            return tour, candidate_info
            
        except subprocess.TimeoutExpired:
            raise RuntimeError("LKH3 execution timed out")
        
        finally:
            # Always clean up temporary files since results are already returned to dataloader
            if cleanup:
                for file_path in [tsp_file, param_file, candidate_file, tour_file]:
                    if os.path.exists(file_path):
                        try:
                            os.remove(file_path)
                        except OSError:
                            pass  # Ignore deletion failures
    
    def _extract_tour_from_file(self, tour_file: str) -> List[int]:
        """
        Extract the tour from LKH3 tour file.
        
        Args:
            tour_file: Path to the tour file
            
        Returns:
            List of node indices representing the tour
        """
        tour = []
        
        with open(tour_file, 'r') as f:
            lines = f.readlines()
        
        in_tour_section = False
        for line in lines:
            line = line.strip()
            
            if "TOUR_SECTION" in line:
                in_tour_section = True
                continue
            
            if in_tour_section:
                if line == "-1" or line == "EOF":
                    break
                
                try:
                    node = int(line)
                    if node > 0:  # LKH uses 1-based indexing
                        tour.append(node - 1)  # Convert to 0-based indexing
                except ValueError:
                    continue
        
        return tour
    
    def _extract_tour_from_output(self, output: str) -> List[int]:
        """
        Extract the tour from LKH3 output.
        
        Args:
            output: LKH3 stdout output
            
        Returns:
            List of node indices representing the tour
        """
        lines = output.split('\n')
        tour = []
        
        # Look for tour in output
        in_tour_section = False
        for line in lines:
            line = line.strip()
            
            if "TOUR_SECTION" in line:
                in_tour_section = True
                continue
            
            if in_tour_section:
                if line == "-1" or line == "EOF":
                    break
                
                try:
                    node = int(line)
                    if node > 0:  # LKH uses 1-based indexing
                        tour.append(node - 1)  # Convert to 0-based indexing
                except ValueError:
                    continue
        
        return tour
    
    def generate_candidate_graph(self, coords: np.ndarray, max_candidates: int = 5, 
                               alpha: float = None, scale: int = 1000) -> Dict:
        """
        Generate only the candidate graph without solving TSP.
        
        Args:
            coords: Array of shape (n, 2) containing x, y coordinates
            max_candidates: Maximum number of candidates per node
            alpha: Alpha value for candidate generation (controls EXCESS parameter)
            scale: Scale factor for distance calculation (default: 1000)
            
        Returns:
            Dictionary containing candidate set information
        """
        _, candidate_info = self.solve_tsp_with_candidates(
            coords, max_candidates=max_candidates, runs=1, alpha=alpha, scale=scale
        )
        return candidate_info


def test_lkh3_wrapper():
    """
    Test function for the LKH3 wrapper with a simple example.
    """
    print("Testing LKH3 Wrapper...")
    
    # Create a simple test case
    coords = np.array([
        [0.0, 0.0],
        [1.0, 0.0],
        [1.0, 1.0],
        [0.0, 1.0],
        [0.5, 0.5]
    ])
    
    print(f"Test coordinates:\n{coords}")
    
    # Initialize wrapper
    wrapper = LKH3Wrapper()
    
    # Test with different alpha values
    for alpha in [0.1, 0.5, 1.0, 2.0]:
        print(f"\n--- ALPHA = {alpha} ---")
        
        try:
            tour, candidate_info = wrapper.solve_tsp_with_candidates(
                coords, max_candidates=5, cleanup=False,
                instance_name=f"test_alpha_{alpha}", alpha=alpha
            )
            
            print(f"Optimal tour: {tour}")
            print(f"Graph dimension: {candidate_info['dimension']}")
            print(f"MST parents: {candidate_info['mst_parents']}")
            print("Candidate edge sets:")
            
            for node_id, candidates in candidate_info['candidates'].items():
                print(f"  Node {node_id}: {candidates}")
                
        except Exception as e:
            print(f"Error: {e}")


if __name__ == "__main__":
    test_lkh3_wrapper() 